#!/usr/bin/env node

/**
 * Fix Syntax Errors - Week 3 Day 1
 * Cleans up malformed interface properties generated by error-blitzkrieg.js
 */

const fs = require('fs');
const path = require('path');

class SyntaxFixer {
    constructor() {
        this.fixed = 0;
    }

    getAllTypeScriptFiles() {
        const tsFiles = [];
        const scan = (dir) => {
            try {
                const items = fs.readdirSync(dir, { withFileTypes: true });
                items.forEach(item => {
                    const fullPath = path.join(dir, item.name);
                    if (item.isDirectory() && !item.name.includes('node_modules') && !item.name.startsWith('.')) {
                        scan(fullPath);
                    } else if (item.name.endsWith('.ts') || item.name.endsWith('.tsx')) {
                        tsFiles.push(fullPath);
                    }
                });
            } catch (error) { }
        };
        scan('src');
        return tsFiles;
    }

    fixSyntax(content) {
        let newContent = content;
        let fixCount = 0;

        // Patterns to remove
        const garbagePatterns = [
            /^\s*\?:\s*any;\s*$/gm,          // ?: any;
            /^\s*0\?:\s*any;\s*$/gm,         // 0?: any;
            /^\s*0\]\?:\s*any;\s*$/gm,       // 0]?: any;
            /^\s*\d+\]\?:\s*any;\s*$/gm,     // 1]?: any;
            /^\s*\[\d+\]\?:\s*any;\s*$/gm,   // [0]?: any;
            /^\s*number\?:\s*any;\s*$/gm,    // number?: any; (if inferred from index)
            /^\s*string\?:\s*any;\s*$/gm     // string?: any;
        ];

        garbagePatterns.forEach(pattern => {
            if (pattern.test(newContent)) {
                const matches = newContent.match(pattern);
                fixCount += matches ? matches.length : 0;
                newContent = newContent.replace(pattern, '');
            }
        });

        return { content: newContent, fixed: fixCount };
    }

    async fixFile(filePath) {
        try {
            let content = fs.readFileSync(filePath, 'utf8');
            const original = content;

            const { content: fixedContent, fixed } = this.fixSyntax(content);

            if (fixed > 0 && fixedContent !== original) {
                fs.writeFileSync(filePath, fixedContent);
                this.fixed += fixed;
                return fixed;
            }
            return 0;
        } catch (error) {
            return 0;
        }
    }

    async launch() {
        console.log('ğŸ”¥ LAUNCHING SYNTAX FIXER');
        console.log('='.repeat(60));

        const tsFiles = this.getAllTypeScriptFiles();
        console.log(`ğŸ“ Found ${tsFiles.length} TypeScript files`);

        let filesProcessed = 0;
        let filesFixed = 0;

        for (const filePath of tsFiles) {
            const fixed = await this.fixFile(filePath);
            filesProcessed++;

            if (fixed > 0) {
                filesFixed++;
                console.log(`âœ… ${path.basename(filePath)}: ${fixed} syntax fixes`);
            }
        }

        console.log('\n' + '='.repeat(60));
        console.log('ğŸ”¥ SYNTAX FIXER RESULTS');
        console.log('='.repeat(60));
        console.log(`ğŸ“Š Files Processed: ${filesProcessed}`);
        console.log(`ğŸ“ Files Fixed: ${filesFixed}`);
        console.log(`ğŸ¯ Syntax Errors Removed: ${this.fixed}`);
    }
}

const fixer = new SyntaxFixer();
fixer.launch().catch(console.error);
